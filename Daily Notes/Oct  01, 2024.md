To transform your Python script into an Azure web application with a field to enter the Order ID, you'll need to:

1. **Create a web application interface**: Use a Python web framework like **Flask** or **Django** to build a web app that accepts user input.

2. **Modify your script to work within the web app**: Adapt your existing code to handle web requests and responses.

3. **Deploy the web app to Azure**: Use Azure App Service or Azure Functions to host your web application.

Since Azure Static Web Apps are designed for static front-end applications with optional serverless backends (Azure Functions), and they don't directly support Python web apps, we'll use **Azure App Service**, which is suitable for hosting Python web applications.

Below, I'll guide you through each step, including code examples.

---

## **Step 1: Create a Flask Web Application**

Flask is a lightweight web framework that's easy to set up and suitable for your needs.

### **1.1. Set Up a Virtual Environment**

Create a new directory for your project and set up a virtual environment:

```bash
mkdir order_transcription_app
cd order_transcription_app
python -m venv venv
```

Activate the virtual environment:

- **Windows**:

  ```bash
  .venv\Scripts\activate
  ```

- **macOS/Linux**:

  ```bash
  source venv/bin/activate
  ```

### **1.2. Install Required Packages**

Install Flask and other dependencies:

```bash
pip install flask requests pydub colorama whisper torch numpy
```

Note: You may need to install additional packages based on your code requirements. If you're using `whisper`, ensure you have the necessary dependencies installed, including PyTorch.

### **1.3. Create the Flask App Structure**

Create a file named `app.py` in your project directory.

**Project Structure:**

```
order_transcription_app/
├── app.py
├── templates/
│   └── index.html
├── static/
│   └── (optional static files like CSS, JS)
├── venv/
└── requirements.txt
```

### **1.4. Write the Flask App Code**

Below is the Flask application code that integrates your existing script and provides a web interface for users to enter the Order ID.

```python
# app.py

import io
import os
import time
import datetime
import requests
import re
from flask import Flask, render_template, request, send_from_directory
from pydub import AudioSegment
from pydub.silence import detect_silence
import whisper
import numpy as np

app = Flask(__name__)

# Function definitions (same as your original code with necessary modifications)

def fetch_data(api_url, params):
    # ... (same as before)
    try:
        response = requests.get(api_url, params=params)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error fetching data from API: {e}")
        return []

def download_audio(url):
    # ... (same as before)
    try:
        response = requests.get(url)
        response.raise_for_status()
        return io.BytesIO(response.content)
    except Exception as e:
        print(f"Failed to download audio: {e}")
        return None

def calculate_duration(call_in_time, call_out_time):
    # ... (same as before)
    try:
        call_in = datetime.datetime.strptime(call_in_time, "%I:%M:%S %p")
        call_out = datetime.datetime.strptime(call_out_time, "%I:%M:%S %p")
        duration = call_out - call_in
        return duration
    except Exception as e:
        return 'N/A'

def audio_to_numpy(audio):
    # ... (same as before)
    samples = audio.get_array_of_samples()
    return np.array(samples).astype(np.float32) / 32768.0  # Normalize to [-1.0, 1.0]

def sanitize_filename(name):
    # ... (same as before)
    return re.sub(r'[^\w\s-]', '', name).replace(' ', '_')

def create_transcription_folder():
    # Modify to create folder in the project directory
    folder_path = os.path.join(app.root_path, "transcriptions")
    if not os.path.exists(folder_path):
        os.makedirs(folder_path)
        print(f"Created folder: {folder_path}")
    return folder_path

def process_call(order_id):
    # Your existing process_call function modified to return the output file path
    try:
        model = whisper.load_model("base")
        print("Whisper model loaded.")
    except Exception as e:
        print(f"Error loading Whisper model: {e}")
        return None

    params = {
        "page": 1,
        "limit": 1,
        "orderId": order_id
    }

    api_url = "https://telephony.ordrai.com/calls"

    start_time = time.time()
    response = fetch_data(api_url, params)

    if isinstance(response, dict) and 'data' in response:
        call_data = response['data']
    else:
        print(f"No data found for Order ID: {order_id}")
        return None

    for call in call_data:
        print(f"Processing data for call ID: {call.get('callSid')}")

        # Extract call details
        store_date = call.get('storeDate')
        call_time = call.get('callTimeAMPM')
        store_name = call.get('storeName')
        agent_name = call.get('agentName', 'Unknown')
        order_id = call.get('orderId', 'N/A')
        call_in_time = call.get('callInTimeAMPM')
        call_out_time = call.get('callOutTimeAMPM')
        call_duration = calculate_duration(call_in_time, call_out_time)

        sanitized_store_name = sanitize_filename(store_name)
        transcription_folder = create_transcription_folder()
        output_file_path = os.path.join(transcription_folder, f"{sanitized_store_name}_{order_id}.html")

        # HTML content initialization
        new_html_content = f"""
        <h2>Transcription Results for {store_name}</h2>
        <p>
            <strong>Date:</strong> {store_date}<br>
            <strong>Time:</strong> {call_time}<br>
            <strong>Store Name:</strong> {store_name}<br>
            <strong>Agent Name:</strong> {agent_name}<br>
            <strong>Order ID:</strong> {order_id}<br>
            <strong>Call Duration:</strong> {call_duration}
        </p>
        <ol>
        """

        recording_url = call.get('recordingURL')
        if not recording_url:
            print(f"No audio URL for call with call ID: {call.get('callSid')}. Skipping.")
            continue

        audio_content = download_audio(recording_url)
        if audio_content:
            try:
                audio = AudioSegment.from_file(audio_content, format="mp3")
                average_dbfs = audio.dBFS
                silence_thresh = average_dbfs - 14
                min_silence_len = 1000

                silence_ranges = detect_silence(audio, min_silence_len=min_silence_len, silence_thresh=silence_thresh)
                silence_ranges_seconds = [(start / 1000, end / 1000, (end - start) / 1000) for start, end in silence_ranges]

                audio_np = audio_to_numpy(audio)
                result = model.transcribe(audio_np)
                segments = result['segments']

                for segment in segments:
                    text = segment['text'].strip()
                    new_html_content += f"<li>{text}</li>\n"

                new_html_content += "</ol>\n"

            except Exception as e:
                print(f"Error processing audio for call with ID {call.get('callSid')}: {str(e)}")
                continue

        end_time = time.time()
        duration_minutes = (end_time - start_time) / 60
        new_html_content += f"<h2><strong>Script Execution Time:</strong> {duration_minutes:.2f} minutes</h2>\n"

        # Write the HTML content to the file
        full_html_content = f"""
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Transcription Results for {store_name}</title>
        </head>
        <body>
        {new_html_content}
        </body>
        </html>
        """
        with open(output_file_path, "w", encoding="utf-8") as f:
            f.write(full_html_content)
        print(f"Transcription results have been saved to {output_file_path}.")

        return output_file_path  # Return the path to the generated HTML file

    return None

# Flask routes

@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        order_id = request.form.get('order_id')
        if order_id:
            output_file_path = process_call(order_id)
            if output_file_path:
                filename = os.path.basename(output_file_path)
                return send_from_directory(directory=os.path.dirname(output_file_path), path=filename, as_attachment=True)
            else:
                return render_template('index.html', error='Failed to process the Order ID.')
        else:
            return render_template('index.html', error='Please enter an Order ID.')
    return render_template('index.html')

if __name__ == '__main__':
    app.run(debug=True)
```

### **1.5. Create the HTML Template**

Create a `templates` directory and add `index.html` inside it.

**templates/index.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Order Transcription</title>
</head>
<body>
    <h1>Order Transcription App</h1>
    {% if error %}
    <p style="color: red;">{{ error }}</p>
    {% endif %}
    <form method="post">
        <label for="order_id">Enter Order ID:</label><br>
        <input type="text" id="order_id" name="order_id"><br><br>
        <input type="submit" value="Submit">
    </form>
</body>
</html>
```

This template provides a simple form for users to enter the Order ID.

---

## **Step 2: Modify the Code for Web Context**

In the `process_call` function:

- Remove any code that relies on user input from the console.
- Ensure paths are correctly set relative to the Flask app.
- Return the path to the generated HTML file so that it can be sent to the user.

In the Flask route:

- Handle GET and POST requests.
- On POST, get the `order_id` from the form, call `process_call(order_id)`, and return the generated HTML file.
- On GET, render the index page with the form.

---

## **Step 3: Test the Application Locally**

Run the Flask app:

```bash
python app.py
```

Access the application in your browser at `http://127.0.0.1:5000/`.

Enter an Order ID and test the functionality.

---

## **Step 4: Deploy the Web App to Azure App Service**

### **4.1. Create an Azure Account and Install Azure CLI**

If you haven't already, create an Azure account and install the Azure CLI.

- **Azure Account**: [Create a free Azure account](https://azure.microsoft.com/free/)
- **Azure CLI Installation**: [Install Azure CLI](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)

### **4.2. Log in to Azure**

```bash
az login
```

### **4.3. Prepare the App for Deployment**

Create a `requirements.txt` file listing all the Python packages your app depends on:

```bash
pip freeze > requirements.txt
```

### **4.4. Create an Azure App Service**

Create a resource group:

```bash
az group create --name OrderTranscriptionRG --location "Your Azure Region"
```

Create an App Service plan:

```bash
az appservice plan create --name OrderTranscriptionPlan --resource-group OrderTranscriptionRG --sku FREE --is-linux
```

Create the web app:

```bash
az webapp create --resource-group OrderTranscriptionRG --plan OrderTranscriptionPlan --name YourUniqueAppName --runtime "PYTHON|3.8"
```

Replace `YourUniqueAppName` with a globally unique name (e.g., `order-transcription-app-123`).

### **4.5. Deploy the App Using Git**

Initialize a Git repository in your project directory:

```bash
git init
```

Add all files and commit:

```bash
git add .
git commit -m "Initial commit"
```

Set the Azure remote:

```bash
az webapp deployment source config-local-git --name YourUniqueAppName --resource-group OrderTranscriptionRG
```

This command will output a Git URL.

Set the remote URL in Git:

```bash
git remote add azure <Git URL from previous command>
```

Push your code to Azure:

```bash
git push azure master
```

You may be prompted for deployment credentials. You can set them using:

```bash
az webapp deployment user set --user-name <username> --password <password>
```

### **4.6. Configure Application Settings**

Set the `FLASK_APP` environment variable:

```bash
az webapp config appsettings set --resource-group OrderTranscriptionRG --name YourUniqueAppName --settings FLASK_APP=app.py
```

### **4.7. Verify the Deployment**

Once deployment is complete, navigate to `https://YourUniqueAppName.azurewebsites.net/` to access your app.

---

## **Step 5: Handling Dependencies**

Ensure that all required dependencies, including system-level packages (like FFmpeg, if used), are available in the Azure environment.

- **FFmpeg**: Azure App Service may not have FFmpeg installed by default. You may need to adjust your code to avoid dependencies that require FFmpeg, or use alternatives.

- **Whisper Model Files**: Since `whisper` models are large, you might need to handle model downloading carefully.

  - **Model Caching**: The first time the app runs, it will download the model. Ensure that the app has enough storage space and permissions.

- **Azure Limitations**: Be aware of the limitations on Azure App Service Free tier, such as limited CPU, memory, and storage.

---

## **Step 6: Securing Your Application**

- **API Keys and Tokens**: If your app uses any API keys or tokens, ensure they are securely stored using Azure App Settings rather than hardcoding them.

- **Error Handling**: Add robust error handling and user-friendly messages in your app.

---

## **Step 7: Optional Enhancements**

- **User Interface Improvements**: Enhance the HTML templates to improve the user experience.

- **Asynchronous Processing**: For long-running tasks, consider implementing asynchronous processing or background jobs.

- **Logging and Monitoring**: Set up logging to monitor your app's performance and errors.

---

## **Important Considerations**

- **Azure Functions vs. App Service**: If you prefer serverless architecture, you can consider using **Azure Functions** with a front-end hosted on Azure Static Web Apps. However, Azure Functions may have cold start times and limitations.

- **Resource Management**: Monitor your app's resource usage to avoid hitting Azure's limits.

---

## **Summary**

By following these steps, you can transform your Python script into a web application that users can interact with via a web browser. The Flask framework allows you to create a simple web interface, and deploying to Azure App Service makes your app accessible over the internet.

---

## **Additional Resources**

- **Flask Documentation**: [Flask Official Docs](https://flask.palletsprojects.com/)
- **Azure App Service Documentation**: [Azure App Service Docs](https://docs.microsoft.com/en-us/azure/app-service/)
- **Deploying Flask Apps to Azure**: [Tutorial on deploying Flask apps to Azure App Service](https://docs.microsoft.com/en-us/azure/app-service/quickstart-python)

---

Let me know if you need further assistance or clarification on any of the steps!

---------------------------------------------------------
---------------------------------------------------------
---------------------------------------------------------


Certainly! I'll help you convert your existing script into a Flask web application that can be deployed on Azure App Service. This will allow you to integrate your transcription and speaker diarization functionality into a web application that can be accessed via HTTP requests.

Below, I'll provide:

1. **The full Flask application code (`app.py`)**.
2. **The `requirements.txt` file** listing all necessary dependencies.
3. **Instructions for deploying the application on Azure App Service**.
4. **Explanation of the code and any additional configurations**.

---

## **1. Flask Application Code (`app.py`)**

Here's the full code for your Flask web application:

```python
# app.py

import io
import os
import time
import datetime
import requests
import re
import torch
import whisperx
import numpy as np
from flask import Flask, request, jsonify
from werkzeug.utils import secure_filename

app = Flask(__name__)

# Function to fetch data from the API using the provided parameters
def fetch_data(api_url, params):
    """Fetch data from API using the specified parameters."""
    try:
        print(f"Request URL: {requests.Request('GET', api_url, params=params).prepare().url}")
        response = requests.get(api_url, params=params)
        response.raise_for_status()
        print(f"Response status code: {response.status_code}")
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error fetching data from API: {e}")
        return []

# Function to download audio files
def download_audio(url):
    """Download audio file and return the file path."""
    if not url:
        print("No audio URL provided.")
        return None
    try:
        response = requests.get(url)
        response.raise_for_status()
        audio_content = response.content
        filename = secure_filename('temp_audio.mp3')
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        with open(filepath, 'wb') as f:
            f.write(audio_content)
        return filepath
    except Exception as e:
        print(f"Failed to download audio: {e}")
        return None

# Function to calculate call duration
def calculate_duration(call_in_time, call_out_time):
    """Calculate call duration given the call in and out times in AM/PM format."""
    try:
        call_in = datetime.datetime.strptime(call_in_time, "%I:%M:%S %p")
        call_out = datetime.datetime.strptime(call_out_time, "%I:%M:%S %p")
        duration = call_out - call_in
        return duration
    except Exception:
        return 'N/A'

# Function to sanitize filenames
def sanitize_filename(name):
    """Sanitize the store name to create a valid file name."""
    return re.sub(r'[^\w\s-]', '', name).replace(' ', '_')

# Function to create the transcription folder
def create_transcription_folder():
    """Create the 'transcriptions' folder if it doesn't exist."""
    folder_path = os.path.join(app.root_path, "transcriptions")
    if not os.path.exists(folder_path):
        os.makedirs(folder_path)
        print(f"Created folder: {folder_path}")
    return folder_path

# Route to process transcription requests
@app.route('/transcribe', methods=['POST'])
def transcribe():
    data = request.get_json()
    if not data or 'order_id' not in data:
        return jsonify({'error': 'Please provide an Order ID.'}), 400

    order_id = data['order_id']
    transcription_result = process_call(order_id)

    if transcription_result:
        return jsonify({'transcription': transcription_result}), 200
    else:
        return jsonify({'error': 'Transcription failed.'}), 500

# Function to process and transcribe each call
def process_call(order_id):
    """Process and transcribe call for the given order ID."""
    # Select device
    device = "cuda" if torch.cuda.is_available() else "cpu"

    # Load WhisperX model
    try:
        model = whisperx.load_model("base", device=device)
        print(f"WhisperX model loaded on {device}.")
    except Exception as e:
        print(f"Error loading WhisperX model: {e}")
        return None

    # Define the query parameters to search by `orderId` only
    params = {
        "page": 1,
        "limit": 1,
        "orderId": order_id
    }

    # Define the API endpoint
    api_url = "https://telephony.ordrai.com/calls"

    # Fetch the data
    response = fetch_data(api_url, params)

    # Ensure the response contains 'data'
    if isinstance(response, dict) and 'data' in response:
        call_data = response['data']
    else:
        print(f"No data found for Order ID: {order_id}")
        return None

    if not call_data:
        print(f"No data found for Order ID: {order_id}")
        return None

    # Process the retrieved call data
    for call in call_data:
        print(f"Processing data for call ID: {call.get('callSid')}")

        store_date = call.get('storeDate')
        call_time = call.get('callTimeAMPM')
        store_name = call.get('storeName', 'Unknown Store')
        agent_name = call.get('agentName', 'Unknown')
        watched_by = call.get('watchedBy', 'No One')
        customer_phone = call.get('custId')
        order_id = call.get('orderId', 'N/A')
        call_type = call.get('orderType')
        queue_type = call.get('queueName')
        call_status = call.get('callStatus')
        call_in_time = call.get('callInTimeAMPM')
        call_out_time = call.get('callOutTimeAMPM')
        call_duration = calculate_duration(call_in_time, call_out_time) if call_in_time and call_out_time else 'N/A'

        # Sanitize store name for the filename
        sanitized_store_name = sanitize_filename(store_name)

        # Create the transcription folder if it doesn't exist
        transcription_folder = create_transcription_folder()

        # Generate the full path for the HTML file
        output_file_path = os.path.join(transcription_folder, f"{sanitized_store_name}.html")

        # Download audio and process transcription with speaker diarization
        recording_url = call.get('recordingURL')
        if not recording_url:
            print(f"No audio URL for call with call ID: {call.get('callSid')}. Skipping.")
            continue

        # Ensure the upload folder exists
        if not os.path.exists(app.config['UPLOAD_FOLDER']):
            os.makedirs(app.config['UPLOAD_FOLDER'])

        audio_file = download_audio(recording_url)
        if audio_file:
            try:
                # Transcribe the audio with WhisperX
                result = model.transcribe(audio_file)

                # Load alignment model and metadata
                model_a, metadata = whisperx.load_align_model(language_code=result["language"], device=device)

                # Perform alignment
                result_aligned = whisperx.align(result["segments"], model_a, metadata, audio_file, device)

                # Load the speaker diarization model
                diarize_model = whisperx.DiarizationPipeline(device=device)

                # Perform diarization
                diarize_segments = diarize_model(audio_file)

                # Assign speaker labels
                result_segments, word_segments = whisperx.assign_word_speakers(result_aligned['segments'], result_aligned['word_segments'], diarize_segments)

                # Build the transcription with speaker labels
                transcription_text = ""
                for segment in result_segments:
                    speaker = segment.get('speaker', 'Unknown Speaker')
                    text = segment['text'].strip()
                    start_time = segment['start']
                    end_time = segment['end']
                    transcription_text += f"{speaker} [{start_time:.2f}s - {end_time:.2f}s]: {text}\n"

                # Optionally, save the transcription to a file
                # with open(output_file_path, "w", encoding="utf-8") as f:
                #     f.write(transcription_text)

                # Clean up temporary files
                os.remove(audio_file)

                return transcription_text

            except Exception as e:
                print(f"Error processing audio for call with ID {call.get('callSid')}: {str(e)}")
                # Clean up temporary files in case of error
                if os.path.exists(audio_file):
                    os.remove(audio_file)
                return None

    return None

if __name__ == '__main__':
    # Set the folder to save uploaded files
    app.config['UPLOAD_FOLDER'] = os.path.join(app.root_path, 'uploads')

    # Ensure the upload folder exists
    if not os.path.exists(app.config['UPLOAD_FOLDER']):
        os.makedirs(app.config['UPLOAD_FOLDER'])

    # Run the app
    app.run(host='0.0.0.0', port=80)
```

---

## **2. `requirements.txt`**

Create a `requirements.txt` file with the following content:

```text
Flask==2.3.2
requests==2.31.0
torch==2.0.1
git+https://github.com/m-bain/whisperX.git
numpy==1.24.2
werkzeug==2.3.7
```

**Notes:**

- **PyTorch Installation:**
  - The version of PyTorch (`torch==2.0.1`) may need to be adjusted based on compatibility with your environment.
  - It's often recommended to install PyTorch using the specific command from the [PyTorch website](https://pytorch.org/get-started/locally/) to ensure compatibility with your hardware (CPU/GPU) and CUDA version.

- **WhisperX Installation:**
  - We install `whisperx` directly from the GitHub repository.

---

## **3. Instructions for Deploying on Azure App Service**

### **A. Prepare Your Application**

1. **Directory Structure:**

   Ensure your project directory contains the following files:

   - `app.py`
   - `requirements.txt`
   - (Optional) `.gitignore` to exclude unnecessary files.
   - Any additional files required by your application.

2. **Ensure FFmpeg is Installed on the Server:**

   - FFmpeg is required by `whisperx` for audio processing.
   - In Azure App Service, you may need to include FFmpeg in your deployment or ensure it's available in the runtime environment.
   - You can use a custom Docker container to include FFmpeg if necessary.

### **B. Create an Azure App Service**

1. **Log in to Azure Portal:**

   - Go to [Azure Portal](https://portal.azure.com).

2. **Create a New Resource:**

   - Click on **Create a resource**.
   - Search for **Web App** and select **Web App**.

3. **Configure the Web App:**

   - **Subscription:** Select your subscription.
   - **Resource Group:** Create a new resource group or select an existing one.
   - **Name:** Provide a unique name for your web app.
   - **Publish:** Choose **Code**.
   - **Runtime Stack:** Select **Python 3.10** or **Python 3.11**.
   - **Region:** Choose the region closest to your users.
   - **Linux Plan:** Create a new App Service Plan or select an existing one.
     - Ensure the App Service Plan has sufficient resources (consider at least a **B1** tier).

4. **Review and Create:**

   - Review your settings and click **Create**.

### **C. Deploy Your Application**

You can deploy your application using various methods. Here, I'll outline deployment via **GitHub Actions**.

1. **Push Your Code to GitHub:**

   - Initialize a git repository in your project directory.
   - Commit your code and push it to a GitHub repository.

2. **Configure Continuous Deployment:**

   - In the Azure Portal, navigate to your Web App.
   - In the **Deployment** section, select **Deployment Center**.
   - Choose **GitHub** as the source.
   - Select your **Organization**, **Repository**, and **Branch**.
   - Click **Save**.

   Azure will generate a GitHub Actions workflow file in your repository (`.github/workflows/azure-webapps-python.yml`) to automate deployment.

3. **Modify the GitHub Actions Workflow (If Necessary):**

   - Ensure that your workflow installs the necessary dependencies.
   - If you need to include FFmpeg, you might need to modify the workflow to install it.

### **D. Configure Application Settings**

1. **Set Environment Variables:**

   - In the Azure Portal, navigate to your Web App.
   - Under **Settings**, select **Configuration**.
   - Add any necessary environment variables.

2. **Adjust Startup Command (If Necessary):**

   - If Azure doesn't automatically detect your Flask app, you may need to specify a startup command.
   - Under **Configuration**, select **General Settings**.
   - In the **Startup Command** field, enter:

     ```
     gunicorn --bind=0.0.0.0 --timeout 600 app:app
     ```

   - The `--timeout 600` option increases the timeout to 10 minutes, which may be necessary for long-running tasks.

### **E. Verify and Test Your Application**

1. **Check Deployment Logs:**

   - In the Azure Portal, navigate to **Deployment Center** to view logs and ensure deployment succeeded.

2. **Test the API Endpoint:**

   - Use a tool like **Postman** or **curl** to send a POST request to your API.

   Example using `curl`:

   ```bash
   curl -X POST https://your-web-app-name.azurewebsites.net/transcribe \
        -H "Content-Type: application/json" \
        -d '{"order_id": "your_order_id_here"}'
   ```

   Replace `your-web-app-name` with the name of your Azure Web App and `your_order_id_here` with a valid Order ID.

3. **Verify the Response:**

   - Ensure that you receive a JSON response containing the transcription or an error message.

### **F. Handle FFmpeg Dependency**

Azure App Service doesn't include FFmpeg by default. Since WhisperX relies on FFmpeg, you have a couple of options:

#### **Option 1: Use a Custom Docker Container**

- **Create a `Dockerfile`:**

  ```dockerfile
  FROM mcr.microsoft.com/azure-functions/python:4-python3.10

  # Install system dependencies
  RUN apt-get update && apt-get install -y ffmpeg

  # Set the working directory
  WORKDIR /home/site/wwwroot

  # Copy the application files
  COPY . /home/site/wwwroot

  # Install Python dependencies
  RUN pip install --upgrade pip
  RUN pip install -r requirements.txt

  # Expose port 80
  EXPOSE 80

  # Run the application
  CMD ["gunicorn", "--bind=0.0.0.0:80", "--timeout", "600", "app:app"]
  ```

- **Build and Push the Docker Image:**

  - Build the Docker image locally and push it to a container registry (e.g., Docker Hub or Azure Container Registry).

- **Configure Azure App Service to Use the Custom Image:**

  - In your Web App settings, under **Container settings**, specify the container registry and image.

#### **Option 2: Use Azure Web App for Containers**

- This is similar to Option 1 but uses a dedicated service for containerized applications.

---

## **4. Explanation and Additional Configurations**

### **A. Understanding the Flask App**

- **Route `/transcribe`:**

  - Accepts a POST request with JSON data containing `order_id`.
  - Calls the `process_call` function to perform transcription.

- **Function `process_call`:**

  - Fetches call data using the provided `order_id`.
  - Downloads the associated audio file.
  - Performs transcription and speaker diarization using WhisperX.
  - Returns the transcription text.

- **Configuration:**

  - The application uses an `UPLOAD_FOLDER` to store temporary audio files.
  - The folder is created if it doesn't exist.

### **B. Security Considerations**

- **Input Validation:**

  - Ensure that user inputs are properly validated and sanitized.
  - Use `secure_filename` to prevent file path traversal attacks.

- **Error Handling:**

  - The application returns appropriate HTTP status codes and error messages.

### **C. Performance Considerations**

- **Long-Running Tasks:**

  - Transcription can be time-consuming.
  - Increase the gunicorn timeout (`--timeout 600`) to prevent the application from timing out during processing.

- **Scaling:**

  - If you expect high traffic or need better performance, consider scaling up your App Service Plan or using Azure VM with more resources.

### **D. Dependencies and Compatibility**

- **PyTorch and WhisperX:**

  - Ensure that the versions of PyTorch and WhisperX are compatible.
  - Test your application locally before deploying.

- **Python Version:**

  - Use Python 3.10 or 3.11, as WhisperX and PyTorch may not be compatible with Python 3.12.

---

## **Testing Your Application**

1. **Local Testing:**

   - Before deploying, test your application locally.
   - Install all dependencies in a virtual environment.
   - Run the Flask app:

     ```bash
     python app.py
     ```

   - Use Postman or curl to send requests to `http://localhost:80/transcribe`.

2. **Deployment Testing:**

   - After deploying to Azure, test the API endpoint as described earlier.
   - Monitor logs in Azure to troubleshoot any issues.

---

## **Final Notes**

- **Azure Costs:**

  - Be aware of the costs associated with running resource-intensive applications on Azure.
  - Monitor your usage and scale resources appropriately.

- **Monitoring and Logging:**

  - Use Azure Monitor and Application Insights to monitor your application's performance and logs.

- **Security:**

  - If your API should not be publicly accessible, implement authentication mechanisms.
  - Consider using Azure API Management for additional security and management features.

---

**Let me know if you have any questions or need further assistance with any of these steps!**