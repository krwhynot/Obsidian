# Azure Deployment Guide

## 1. Recommended Architecture

### Option A: Azure Container Apps (Recommended)
Best for batch processing with good cost optimization and scalability.

```yaml
# container-app.yaml
apiVersion: 2023-05-01
location: eastus
name: audio-processor
resourceGroup: audio-processing-rg
type: Microsoft.App/containerApps
properties:
  managedEnvironmentId: /subscriptions/{subscription-id}/resourceGroups/{resource-group}/providers/Microsoft.App/managedEnvironments/{environment-name}
  configuration:
    ingress:
      external: false
      targetPort: 80
    secrets:
      - name: storage-connection
        value: {storage-connection-string}
  template:
    containers:
      - name: audio-processor
        image: {your-container-registry}.azurecr.io/audio-processor:latest
        resources:
          cpu: 2.0
          memory: 4Gi
        env:
          - name: AZURE_STORAGE_CONNECTION_STRING
            secretRef: storage-connection
    scale:
      minReplicas: 0
      maxReplicas: 10
      rules:
        - name: queue-scaling
          custom:
            type: azure-queue
            metadata:
              queueName: audio-processing-queue
              messageCount: "1"
```

### Option B: Azure Functions
Good for event-driven processing with automatic scaling.

```python
# function_app.py
import azure.functions as func
import logging

app = func.FunctionApp()

@app.blob_trigger(arg_name="myblob", 
                 path="audio-files/{name}",
                 connection="AzureWebJobsStorage")
def process_audio(myblob: func.InputStream):
    logging.info(f"Processing blob: {myblob.name}")
    # Your processing logic here
```

## 2. Infrastructure Requirements

### Azure Resources Needed
```bicep
// main.bicep
param location string = resourceGroup().location
param environmentName string

// Storage Account
resource storageAccount 'Microsoft.Storage/storageAccounts@2021-08-01' = {
  name: 'audioprocessing${uniqueString(resourceGroup().id)}'
  location: location
  sku: {
    name: 'Standard_LRS'
  }
  kind: 'StorageV2'
  properties: {
    supportsHttpsTrafficOnly: true
  }
}

// Container Registry
resource acr 'Microsoft.ContainerRegistry/registries@2021-06-01-preview' = {
  name: 'audioacr${uniqueString(resourceGroup().id)}'
  location: location
  sku: {
    name: 'Basic'
  }
  properties: {
    adminUserEnabled: true
  }
}

// Key Vault
resource keyVault 'Microsoft.KeyVault/vaults@2021-06-01-preview' = {
  name: 'audiovault${uniqueString(resourceGroup().id)}'
  location: location
  properties: {
    tenantId: subscription().tenantId
    sku: {
      family: 'A'
      name: 'standard'
    }
    accessPolicies: []
  }
}
```

## 3. Containerization

### Dockerfile
```dockerfile
FROM python:3.9-slim

# Install system dependencies
RUN apt-get update && apt-get install -y \
    ffmpeg \
    libsndfile1 \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Set environment variables
ENV PYTHONUNBUFFERED=1
ENV AUDIO_DIR=/tmp/audio
ENV MAX_DURATION_MINUTES=30

# Create necessary directories
RUN mkdir -p /tmp/audio

CMD ["python", "main.py"]
```

## 4. Deployment Scripts

### Deploy Infrastructure
```bash
#!/bin/bash
# deploy.sh

# Variables
RESOURCE_GROUP="audio-processing-rg"
LOCATION="eastus"
APP_NAME="audio-processor"

# Create resource group
az group create --name $RESOURCE_GROUP --location $LOCATION

# Deploy infrastructure
az deployment group create \
  --resource-group $RESOURCE_GROUP \
  --template-file main.bicep \
  --parameters environmentName=$APP_NAME

# Build and push container
az acr build --registry $ACR_NAME --image audio-processor:latest .
```

## 5. Monitoring Setup

```python
# Add to main.py
from opencensus.ext.azure.log_exporter import AzureLogHandler
from opencensus.ext.azure import metrics_exporter
from opencensus.stats import stats as stats_module

# Setup Azure Monitor
logger = logging.getLogger(__name__)
logger.addHandler(AzureLogHandler(
    connection_string='InstrumentationKey=your-key-here')
)

# Create metrics exporter
exporter = metrics_exporter.new_metrics_exporter(
    enable_standard_metrics=True,
    connection_string='InstrumentationKey=your-key-here'
)
```

## 6. Performance Optimization

### Storage Configuration
```python
# Add to config.py
@dataclass
class AzureConfig:
    STORAGE_ACCOUNT: str
    CONTAINER_NAME: str
    QUEUE_NAME: str
    BATCH_SIZE: int = 32
    MAX_CONCURRENT_PROCESSES: int = 4
```

### Batch Processing
```python
from azure.storage.blob import BlobServiceClient
from azure.storage.queue import QueueServiceClient
from concurrent.futures import ThreadPoolExecutor

def process_batch(batch_files):
    with ThreadPoolExecutor(max_workers=Config.MAX_CONCURRENT_PROCESSES) as executor:
        executor.map(process_single_file, batch_files)
```

## 7. Cost Optimization

1. Use Azure Spot Instances when possible
2. Implement auto-scaling based on queue length
3. Use Azure Storage lifecycle management
4. Implement proper cleanup of temporary files

## 8. Security Configuration

```python
# Add to main.py
from azure.identity import DefaultAzureCredential
from azure.keyvault.secrets import SecretClient

credential = DefaultAzureCredential()
secret_client = SecretClient(
    vault_url="https://your-vault.vault.azure.net/",
    credential=credential
)
```

## 9. Implementation Steps

1. **Prepare Infrastructure**
   ```bash
   # Initialize infrastructure
   az login
   az account set --subscription <subscription-id>
   ./deploy.sh
   ```

2. **Configure Storage**
   ```bash
   # Create storage container
   az storage container create \
     --name audio-files \
     --account-name <storage-account> \
     --auth-mode login
   ```

3. **Deploy Application**
   ```bash
   # Deploy container app
   az containerapp up \
     --name audio-processor \
     --resource-group audio-processing-rg \
     --source .
   ```

4. **Setup Monitoring**
   ```bash
   # Create Log Analytics workspace
   az monitor log-analytics workspace create \
     --resource-group audio-processing-rg \
     --workspace-name audio-processor-logs
   ```

## 10. Best Practices

1. Use managed identities for authentication
2. Implement proper error handling and retry logic
3. Use Azure Key Vault for secrets management
4. Implement proper logging and monitoring
5. Use proper network security groups
6. Implement backup and disaster recovery
7. Use proper RBAC for access control
8. Implement proper cost management



**HungerRushUpdater**: LookingGlass  RunBooks(Pushing System Updates)
**HungerRushRMPosAgent:**  RM Syncing(Menu, new Reporting)
**HungerRush POS Service:**
ADX

