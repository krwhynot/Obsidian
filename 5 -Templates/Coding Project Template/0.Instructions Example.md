Below is a filled-out template example for a **simple Python “Task Manager” application**. You can use this as a guide or reference for your own projects. The structure, principles, and guidelines can be adapted to more complex systems as needed.

---

# [Project Name] Development Instructions

## Project Overview

**Project Name:** Simple Python Task Manager  
**Primary Purpose:**

- Provide a command-line tool to create, view, update, and delete tasks
- Demonstrate basic CRUD operations and data persistence

**Core Features:**

- Add new tasks (with due dates and priority)
- List all tasks or filter by status
- Mark tasks as complete or in-progress
- Remove tasks from the system

**Target Platform:**

- Python Command-Line Interface (CLI)

---

## Core Architecture Principles

This application uses a **layered** approach, separating the data, business logic, and user interface:

- **Layered Architecture**
    - **Data Layer:** Manages all interactions with the storage system (e.g., local file or SQLite database).
    - **Services Layer:** Contains business logic (e.g., validating task data, managing status changes).
    - **Application Layer (CLI):** Handles user interactions via the command line, routes requests to services, and outputs results.

### Directory Structure

```
src/
├── config/          # Configuration management
├── core/            # Core interfaces and models
├── services/        # Business logic implementations
├── data/            # Data persistence layer
├── app/             # Main CLI entry point
└── utils/           # Shared utilities and helpers
```

---

## Configuration Management

Handles environment-based settings and other application-wide configurations.

1. **Environment Management:**
    
    - Store environment variables in a `.env` file (e.g., database URL, log level).
    - Default configurations in `config/default.yaml`.
    - Override mechanisms for development/staging/production in separate config files.
    - **Security:** Ensure sensitive credentials (database passwords, API keys) are not committed to version control.
2. **Settings Structure:**
    
    - **File paths**: Paths for storing local data (e.g., `data/tasks.db`).
    - **API configurations (if applicable)**: Could be empty for this CLI version, or placeholders for future expansion.
    - **Processing parameters**: Task limit constraints, default statuses (e.g., “Todo,” “In Progress,” “Completed”).
    - **Resource limits**: Basic Python memory usage is typically sufficient for small task lists, but plan for scale if needed.

---

## Core Interfaces

Defines how components communicate. In Python, these can be formal or simply conventions (using abstract base classes or protocols).

1. **TaskRepository Protocol (Interface 1):**
    
    - **Primary Responsibilities**: Handle CRUD operations for tasks.
    - **Key Methods**:
        - `create_task(task_data)`
        - `get_task_by_id(task_id)`
        - `update_task(task_id, updated_data)`
        - `delete_task(task_id)`
        - `list_tasks(filter_criteria)`
    - **Error Handling Approach**:
        - Raise custom `TaskNotFoundError` if a task ID doesn’t exist.
        - Raise `TaskValidationError` for invalid data.
    - **Performance Requirements**:
        - Handle up to a few thousand tasks efficiently in a local file/SQLite DB.
2. **TaskService Protocol (Interface 2):**
    
    - **Primary Responsibilities**: Encapsulate business logic for tasks (e.g., validating tasks, setting status).
    - **Key Methods**:
        - `create_task(name, due_date, priority)`
        - `complete_task(task_id)`
        - `list_pending_tasks()`, `list_completed_tasks()`
    - **Error Handling Approach**:
        - Catch repository exceptions, re-raise or handle gracefully for user feedback.
    - **Performance Requirements**:
        - Must respond quickly to user input in the CLI; minimal overhead beyond data operations.

---

## Data Models

Outlines the data structures used in the application.

1. **Task Model (Model 1):**
    
    - **Fields and Types**:
        - `task_id` (int or UUID)
        - `name` (string)
        - `due_date` (date string or datetime object)
        - `priority` (string or integer)
        - `status` (string; values like “Todo,” “In Progress,” “Completed”)
    - **Validation Rules**:
        - `name` must not be empty.
        - `priority` must be within an acceptable range (e.g., 1-5).
    - **Relationships**:
        - Not applicable for a simple single-entity system.
    - **State Management**:
        - The repository or the service layer updates `status` and `due_date` as needed.
2. **(Optional) User Model (Model 2):**
    
    - **Fields and Types**:
        - `user_id` (int or UUID)
        - `username` (string)
        - `email` (string)
    - **Validation Rules**:
        - `username` must be unique.
        - `email` must be valid format.
    - **Relationships**:
        - Could be related to tasks if multi-user is supported.
    - **State Management**:
        - Potential for user-specific tasks, not mandatory for the minimal version.

---

## Implementation Guidelines

1. **Error Handling**:
    
    - **Exception Hierarchy**:
        - `BaseTaskError`
            - `TaskNotFoundError`
            - `TaskValidationError`
    - **Logging Strategy**:
        - Use Python’s `logging` module to record errors in a log file.
    - **Recovery Mechanisms**:
        - For data read/write errors, retry or notify the user.
    - **User Feedback Approach**:
        - Print clear messages to the console, such as “Task not found. Please check the ID.”
2. **Resource Management**:
    
    - **Cleanup Procedures**:
        - Close database connections after each operation (if using SQLite or other DB).
    - **Resource Monitoring**:
        - For a simple CLI, Python default metrics are sufficient; advanced apps might use monitoring tools.
    - **Concurrent Processing**:
        - Not typically required in a small CLI. Consider threading if tasks scale.
    - **Memory Management**:
        - Keep tasks loaded from the database only when needed.
3. **Testing Requirements**:
    
    - **Coverage Targets**: Aim for at least 80% test coverage.
    - **Test Frameworks**: Use `pytest` or the built-in `unittest`.
    - **Test Categories**:
        - Unit Tests (focus on `TaskService` and `TaskRepository`)
        - Integration Tests (ensure the CLI interacts properly with services)
    - **CI/CD Integration**:
        - Use GitHub Actions or similar to run tests on each push.
4. **Performance Considerations**:
    
    - **Performance Targets**: Respond to user commands in under one second for up to 1,000 tasks.
    - **Optimization Strategies**:
        - Use efficient lookups (indexes if using SQLite).
        - Minimize repeated disk reads/writes.
    - **Monitoring Approach**:
        - Basic logging for slow queries or large data sets.
    - **Scaling Considerations**:
        - For larger scale, consider a more robust DB and caching.

---

## User Interface Standards

1. **Layout Guidelines (CLI)**:
    
    - Display a help menu (usage instructions) when started without arguments or with `--help`.
    - Clear prompts for each user action (e.g., “Enter task name:”).
2. **User Interaction**:
    
    - **Feedback Mechanisms**: Show success or error messages immediately.
    - **Progress Indication**: For longer operations, show a loading spinner or progress text.
    - **Shortcut Systems**: Command-line arguments (e.g., `python task_manager.py --add "Buy milk"`).
    - **Help Documentation**: Provide usage details in `README.md` or inline with `--help`.
3. **Status Management**:
    
    - **Progress Tracking**: For each operation, console output indicates success or error.
    - **Error Display**: Show relevant error message with possible solutions.
    - **System Health Indicators**: Typically minimal in a CLI. Could log to a file.
    - **Performance Metrics**: Log times to complete each operation in debug mode.

---

## Data Storage

**Specify database or storage system**: Use a local SQLite database named `tasks.db`.

1. **Schema Design**:
    
    - **Table Structures**:
        - Table `tasks`: `task_id`, `name`, `due_date`, `priority`, `status`.
    - **Relationships**: None for single-entity.
    - **Indexing Strategy**: Index on `task_id` as primary key.
    - **Migration Approach**:
        - Use simple scripts or an ORM (e.g., SQLAlchemy) to handle schema creation and updates.
2. **Data Management**:
    
    - **CRUD Operations**:
        - `INSERT` for new tasks, `SELECT` for listing, `UPDATE` for changes, `DELETE` for removals.
    - **Transaction Handling**:
        - Wrap write operations in transactions to ensure data integrity.
    - **Backup Strategy**:
        - Copy `tasks.db` to a safe location or a cloud backup daily/weekly.
    - **Recovery Procedures**:
        - Restore the last known good backup if corruption or accidental deletion occurs.

---

## Output Generation

For the CLI, output is primarily text-based.

1. **Content Requirements**:
    
    - **Required Sections**:
        - Task list with columns: ID, Name, Due Date, Priority, Status.
    - **Data Formatting**:
        - Align columns in a table-like format, or use line-by-line listings.
    - **Visual Elements**:
        - Simple ASCII tables or color-coded text for priorities (optional).
    - **Export Formats**:
        - Provide an option to export tasks to a `.csv` or `.json` file.
2. **Interactive Features**:
    
    - **User Controls**: Command-line arguments or interactive prompts.
    - **Search Capabilities**: Filter tasks by status, priority, or name substring.
    - **Filter Options**: E.g., `--status "In Progress"`.
    - **Export Mechanisms**: E.g., `--export csv` to output to a CSV file.

---

## Development Workflow

1. **Version Control**:
    
    - **Branch Strategy**:
        - `main` branch for stable releases, `dev` branch for ongoing development, and feature branches (e.g., `feature/add-task`) for new changes.
    - **Commit Standards**:
        - Use descriptive commit messages (e.g., `feat: add task creation flow`).
    - **Review Process**:
        - Open a pull request for each feature branch into `dev`, requiring at least one review.
    - **Release Workflow**:
        - Merge `dev` into `main` with a version tag (e.g., `v1.0.0`).
2. **Documentation**:
    
    - **Code Documentation**:
        - Docstrings for classes and functions.
    - **API Documentation**:
        - If building a REST API in the future, use tools like Sphinx or Swagger.
    - **User Guides**:
        - Provide a `README.md` with setup, usage, and examples.
    - **Maintenance Logs**:
        - Maintain a `CHANGELOG.md` detailing feature additions, bug fixes, etc.
3. **Code Quality**:
    
    - **Style Guidelines**:
        - Follow PEP 8 for Python code style.
    - **Naming Conventions**:
        - Use snake_case for functions and variables, PascalCase for classes.
    - **Documentation Standards**:
        - Each function should include a description, parameters, and return value docstring.
    - **Review Checklist**:
        - Ensure tests pass.
        - Confirm docstrings are updated.
        - Verify no linting errors.

---

## File Management

1. **File Operations Protocol**:
    
    - **Read Operations**:
        - Load tasks from SQLite on each “list” operation or upon startup.
    - **Write Operations**:
        - Insert or update tasks in the DB on create/update.
    - **Update Procedures**:
        - Ensure changed tasks are committed in a transaction.
    - **Delete Safeguards**:
        - Confirm user action before deleting tasks (optional prompt).
2. **Development Process**:
    
    - **Setup Procedures**:
        - Create a virtual environment (`python -m venv venv`), install dependencies (`pip install -r requirements.txt`).
    - **Development Workflow**:
        - Implement features on separate branches; run lint and tests locally.
    - **Testing Process**:
        - Run `pytest tests/` or `python -m unittest` after each feature.
    - **Deployment Steps**:
        - Tag a release and build distribution if needed (`python setup.py sdist bdist_wheel`).

---

## Deployment Considerations

1. **Installation Requirements**:
    
    - **System Requirements**:
        - Python 3.8+ (for typing, f-strings).
    - **Dependencies**:
        - `sqlite3` (built into Python), `click` (for CLI, if desired), `SQLAlchemy` (if using an ORM).
    - **Installation Steps**:
        - Clone repo, create virtual environment, install requirements.
    - **Update Procedures**:
        - Pull new code, run `pip install -r requirements.txt` again if needed.
2. **Configuration**:
    
    - **Environment Setup**:
        - Populate `.env` with database paths, log level, etc.
    - **User Settings**:
        - Preferences for output (plain text vs. colored).
    - **Security Configuration**:
        - Keep `.env` out of version control, sanitize user input if expanded.
    - **Logging Setup**:
        - Use rotating file handler to avoid large log files.

---

## Document Editing Standards

1. **Documentation Updates**:
    
    - **Update Procedures**:
        - Edit relevant `.md` files with each feature addition or change.
    - **Review Process**:
        - Team members or peers review doc changes in pull requests.
    - **Version Tracking**:
        - Increment doc version or add an entry in `CHANGELOG.md`.
    - **Distribution Method**:
        - Host docs in the repository Wiki or in `/docs` folder.
2. **Content Management**:
    
    - **Style Guidelines**:
        - Keep consistent headings and bullet points for clarity.
    - **Format Requirements**:
        - Markdown formatting with headings, subheadings, code blocks.
    - **Review Process**:
        - At least one approval before merging doc changes.
    - **Update Workflow**:
        - Use the same branching strategy as for code.

---

[Additional sections or customization can be added based on project needs]

---

## Example Next Steps

1. **Set Up Repository**: Create a Git repository and initialize the directory structure above.
2. **Start Implementation**: Begin coding the `TaskRepository` class and a simple `main.py` or `cli.py` in `app/`.
3. **Add Basic CLI Commands**: Use Python’s `argparse` or a library like `click` to implement `create`, `list`, `update`, `delete` commands.
4. **Write Tests**: Add unit tests for each command and for repository operations.
5. **Document**: Fill out the `README.md` with instructions on how to run the app and tests.

---

This example serves as a **template** demonstrating how to organize and document a simple Python project following structured architecture and coding best practices. Adjust each section according to your specific project’s requirements.