When creating resources for your project, based on the provided materials, here are several key points to consider:

- **Naming and Identification:**
    - Resource names must be unique across Azure for some resource types.
    - Be careful about the values you assign to resource names like `<appName>` and `<resourceGroup>`, as they are used later. Unique strings can be used in templates to help ensure unique names.
- **Resource Selection and Compatibility:**
    - Carefully choose the Azure compute service (like App Service, AKS, Container Apps, Functions, VMs) based on your application type, workloads, requirements (e.g., GPU access, Kubernetes API access, code-based vs. containerized, serverless vs. dedicated compute).
    - Infrastructure readiness, including the hosting platform's scalability and support for autoscaling, is critical.
    - Compatibility with specific runtime stacks (like Java SE, Jakarta EE, MicroProfile versions) and underlying application servers (like JBoss EAP) is necessary. Ensure your chosen Azure platform supports the required Java version.
    - Migrating existing applications requires careful inventory and assessment of dependencies (data sources, file system usage, scheduled jobs, JMS, JCA, JAAS, Resource Adapters, external processes, secrets, certificates) to determine if reconfiguration or refactoring is needed for compatibility with the target Azure service. Scheduled jobs should NOT be used directly with Azure App Service.
    - Choosing data stores involves answering detailed questions about data format, size, scale, relationships, consistency, schema flexibility, concurrency, performance, reliability, replication, limits, region availability, portability, licensing, cost, security, networking, required skill sets, and client support.
    - Compliance requirements (like data residency or processing location for sensitive data) can constrain service choices or require specific deployment models (e.g., using containers to run services on-premises or in specific compute environments). Security team requirements (e.g., deny-by-default network controls) can override preferred PaaS solutions and necessitate using services like AKS.
- **Configuration and Secrets Management:**
    - Properly configure resource settings such as Region, Hosting plan (pricing tier), Runtime stack, and Resource Group during creation.
    - Migrating applications might require reconfiguring JNDI resources, file system paths, or external dependencies. This often involves using startup scripts or environment variables.
    - Sensitive information (passwords, connection strings, SSL keys) should be stored securely using services like Azure Key Vault or injected via application settings, rather than in configuration files directly deployed with the application or stored in directories like `/home`.
    - Ensure correct configuration files and dependencies (like JDBC or Resource Adapter JARs) are placed in the correct locations within the application server directories.
    - Consider how secrets will be populated in the new environment.
- **Dependencies and Sequencing:**
    - Resources often have dependencies on each other (e.g., an App Service depends on an App Service Plan, app settings depend on the App Service site and potentially an App Configuration store).
    - When automating deployments using Infrastructure as Code (IaC) tools like ARM templates, Bicep, or Terraform, you must explicitly define dependencies (`dependsOn`) to ensure resources are created in the correct order.
    - Minimizing external dependencies reduces potential points of failure for your system.
- **Cost:**
    - Understand the pricing model for the services you choose; you pay for consumed resources, and total costs include service consumption, network bandwidth, storage, IP addresses, and operations costs (DevOps, incident response, DR).
    - Pricing varies by service tier and size. JBoss EAP on App Service is only available on Premium V3 and Isolated V2 tiers.
    - Account for capacity needed for scaling (including staging/canary deployments or deployment slots) which impacts App Service plan cost.
    - Consider cost optimization strategies for specific services like AKS, Container Apps, and Azure Functions. Using capacity pools for multitenant databases can be cost effective. Maintaining existing database solutions might be less costly than adding new services for features like vector search.
    - Azure Storage mounted as a network share is not the default storage and is billed separately.
    - Using existing, already deployed services where possible can increase resource density and utilization, potentially saving cost. Tags can help correlate costs across resource groups.
- **Reliability and Availability:**
    - Infrastructure readiness assessment should include evaluating the disaster recovery plan, data backup plan, and data replication strategy.
    - Design for redundancy, potentially scaling out across multiple availability zones using zone-redundant services.
    - Choosing an appropriate hosting platform influences availability and disaster recovery capabilities and SLAs.
    - Minimize external dependencies on components and processes, as they can introduce points of failure.
    - Avoid single points of failure in your architecture (e.g., do not use a regional resource as a router for globally distributed backends).
    - Resource characteristics based on architectural layers (global, regional, stamp) regarding lifetime, state, reach, dependencies, scale limits, and availability/DR are critical design considerations impacting overall reliability.
    - Data platform choice depends on desired responsiveness (always available?), durability, and resiliency (automatic failover).
- **Scalability and Performance:**
    - Choose hosting platforms that support the required scalability and autoscaling features. Assess how long it takes the platform to scale.
    - For microservices packaged as WARs or EARs, consider breaking them into separate applications on App Service to scale them independently for better resource utilization.
    - Model and optimize your system's scalability, considering factors like contention (waiting for shared resources) and coherency (data consistency delay). Calculate the maximum effective capacity to avoid waste.
    - Assess performance requirements for data stores (ingestion/processing rates, response times, scale limits, read/write patterns) and choose services/configurations that meet them. Partitioning schemes impact scalability.
    - Understand that certain workloads, like processing free-form text, require significant computational resources (potentially GPU) and are time-intensive.
    - System slowdowns and failures can occur due to resource exhaustion (e.g., running out of database connections). Proper usage monitoring is needed for capacity planning.
- **Security:**
    - Implement authentication and authorization mechanisms.
    - Use network security controls like network security policies and firewalls (L4, L7) to manage communication between services and protect from external access. Private endpoints can isolate resources from public attacks.
    - Harden public endpoints and restrict access to origin servers, potentially using services like Azure Front Door with WAF or Private Link. Set minimum TLS versions.
    - Manage secrets securely using dedicated services or features.
    - Define how JAAS will be configured if used by your application.
    - Ensure data stores meet required encryption (at rest), authentication, and auditing needs. Manage certificates used for SSL endpoints.
    - Security controls are applied to mitigate threats that could affect the availability and reliability of mission-critical workloads. Regional resources, involved in business operations, often require higher security controls and protection from direct internet traffic.
- **Architecture and Design:**
    - Selecting the right architecture style (microservices, N-tier, etc.) based on business drivers and required characteristics is crucial, and switching styles later can be costly.
    - Design your application platform in layers (global, deployment stamp, regional) to provide logical/physical segmentation, roles/privileges, and deployment strategies for increased reliability.
    - Consider integration complexities when interacting with external systems, especially legacy ones, and potential architectural implications like needing an anti-corruption layer.
    - Data store selection should align with your overall architecture design.
- **Operations and Management:**
    - Assess infrastructure readiness regarding provisioning automation using IaC, deployment infrastructure SLAs, monitoring capabilities, and self-healing features.
    - Plan for the maintenance overhead associated with managing infrastructure components like self-hosted build agents if used.
    - Design your monitoring setup carefully; for mission-critical workloads spanning multiple regions, avoid a single, centralized data sink for all monitoring data to prevent a single point of failure. Use cross-workspace querying for a unified view instead. Dedicate monitoring resources for the critical path.
    - Implement usage monitoring and issue tracking to identify problems like resource exhaustion and facilitate diagnosis.
    - Leverage available troubleshooting documentation if issues arise during setup or operation.
- **Environment Management:**
    - Work with your platform team to design a subscription topology that meets your workload's reliability target, potentially involving multiple dedicated or consolidated subscriptions for different environments.
    - Ensure isolation between production and other environments 
    - Sharing platform-provided resources in lower environments can help them reflect production. Avoid sharing application-owned resources between environments like deployment stamps.
- **Responsible Design and Sustainability:**
    - Consider the potential harms your technology could cause to stakeholders and the environment (resource exploitation, energy use). Use transparency documents for the services you select to understand how their functionalities and limitations introduce or mitigate risks in your specific use case.
    - Designing for cost optimization can also align with sustainability goals. Using a minimum viable system architecture and appropriate storage solutions (like Data Lake Storage) are recommended for sustainable workloads.

